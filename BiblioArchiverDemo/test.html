
<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 开发中的 Self-Manager 模式 · sunnyxx的技术博客</title><meta name="description" content="iOS 开发中的 Self-Manager 模式 - sunnyxx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/doge-logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/1364395395/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/forkingdog" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 开发中的 Self-Manager 模式</h1><div class="post-time">2015年12月19日</div><div class="post-content"><p><code>Self-Manager</code> 源于我们团队内部的黑话，“诶？你刚去的创业公司有几个 iOS 开发啊？” “就我一个” “靠，你这是 Self-Manager 啊”</p>
<p>最近，这个思路被我们当做了一种设计模式，即<strong>赋予一个 Widget 更大的权利，让其自己负责自己的事件。</strong><br>举个简单的栗子，这种负责展示头像的视图：<br><img src="http://ww1.sinaimg.cn/large/51530583jw1ez4xxydguqj20k40a4ac0.jpg" width="320"><br>它的职责包括：</p>
<ol>
<li>通过传入的 URL，加载并展示头像图片</li>
<li>显示一些附属信息，比如大V的标志</li>
<li>将用户点击头像的事件传递给外层的 View Controller 跳转到用户信息页面</li>
</ol>
<p>于是乎这个 Widget 的 API 可以长这个样子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDAvatarView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="comment">// 假设 VIPInfo 是某个 Entity</span></span><br><span class="line">- (<span class="keyword">void</span>)configureWithAvatarURL:(<span class="built_in">NSURL</span> *)URL VIPInfo:(<span class="keyword">id</span>)info tapped:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用这个控件的人只需要调用这个 configure 方法就可以配置入参和事件处理。但随之而来的就是一些蛋疼的问题：</p>
<ol>
<li>configure 的调用者是 superview，上面的例子中也就是一个 UITableViewCell，但 Cell 这层并不知道自己的 ViewController 是谁，于是乎还得向上一级传递这个点击事件，直到能获取到 NavigationController，然后 Push 一个用户信息的页面。</li>
<li>这个 Avatar View 在 App 的各个地方都可能粗线，而且行为一致，那就意味着事件处理的 block，要散落在各个页面中，同时也带来了很多“只是为向上一层级转发事件”的 <strong>“Middle Man”</strong></li>
</ol>
<p>为解决这个问题，就需要给这个 View 放权，让其自己 Handle 自己的事件，也就是 <code>Self-Managed</code>，为了不破坏 View 的纯洁性，比较好的实践是在 Category 中实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDAvatarView</span> (<span class="title">FDAvatarViewSelfManager</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)selfManagedConfigureWithAvatarURL:(<span class="built_in">NSURL</span> *)URL VIPInfo:(<span class="keyword">id</span>)info uid:(<span class="built_in">NSString</span> *)uid;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>实现时最好要调用 View 主类提供的 API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FDAvatarView</span> (<span class="title">FDAvatarViewSelfManager</span>)</span></span><br><span class="line"><span class="comment">// 为后一个页面的创建增加了个 UID 参数</span></span><br><span class="line">- (<span class="keyword">void</span>)selfManagedConfigureWithAvatarURL:(<span class="built_in">NSURL</span> *)URL VIPInfo:(<span class="keyword">id</span>)info <span class="built_in">UID</span>:(<span class="built_in">NSString</span> *)<span class="built_in">UID</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> configureWithAvatarURL:URL VIPInfo:info tapped:^&#123;</span><br><span class="line">    	<span class="comment">// 假设 App 结构是 Root -&gt; TabBar -&gt; Navigation -&gt; ViewController</span></span><br><span class="line">        <span class="built_in">UITabBarController</span> *tabBarControler = (<span class="keyword">id</span>)[<span class="built_in">UIApplication</span>.sharedApplication.delegate.window.rootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navigationController = tabBarControler.selectedViewController;</span><br><span class="line">        <span class="comment">// 创建用户信息 View Controller</span></span><br><span class="line">        FDUserProfileViewController *profileViewController = [FDUserProfileViewController viewControllerWith<span class="built_in">UID</span>:<span class="built_in">UID</span>];</span><br><span class="line">        [navigationController pushViewController:profileViewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里用到了类似 AOP 的思路，添加了对 App 层级的耦合，如果觉得这样的耦合方式不妥的话，也可以封装个全局方法去取到当前顶层的 Navigation Controller。<br>这样，FDAvatarView 的调用者只需要配置入参，其余的它自己全能搞定了，即使 App 内很多处出现头像，逻辑代码也只有一份。</p>
<p>接下来再来个例子：</p>
<p><img src="http://ww1.sinaimg.cn/large/51530583jw1ez4zzt5l4aj20k60lqgn2.jpg" width="320"></p>
<p>这个点赞的按钮功能上有几个职责：</p>
<ol>
<li>显示已有的点赞数</li>
<li>点击按钮后执行一个小动画，点赞数 +1，同时发送网络请求。</li>
<li>若已经点赞，点击执行反向操作</li>
<li>若网络请求发送失败，则回退成点击前的状态</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/51530583jw1ez5055l1exj20k60lu3zz.jpg" width="320"></p>
<p>这个控件的 API 可以设计成这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDLikeButton</span> : <span class="title">UIButton</span></span></span><br><span class="line">- (<span class="keyword">void</span>)configureLikeStatus:(<span class="built_in">BOOL</span>)likeOrNot count:(<span class="built_in">NSInteger</span>)count animated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>因为继承自 UIButton，所以外部可以直接设置其 action，就不增加 tappedHandler 的参数了。外部在点击事件中需要调用这个配置方法，播放点赞动画，紧接着发送一个网络请求，若网络请求失败，可以再次调用这个 API 的无动画版本回滚状态。但像上一个例子一样，网络请求和事件处理逻辑相同，但代码却分部在各个页面中，于是给这个 View 增加 Self-Managed 模式的 Category：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FDLikeButton</span> (<span class="title">FDLikeButtonSelfManager</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)selfManagedConfigureWithLikeStatus:(<span class="built_in">BOOL</span>)likeOrNot count:(<span class="built_in">NSInteger</span>)count;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>伪代码的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FDLikeButton</span> (<span class="title">FDLikeButtonSelfManager</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)selfManagedConfigureWithLikeStatus:(<span class="built_in">BOOL</span>)likeOrNot count:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    [<span class="keyword">self</span> configureLikeStatus:likeOrNot count:count animated:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(likeButtonTapped:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)likeButtonTapped:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">// +1 or -1 with animation</span></span><br><span class="line">    <span class="comment">// Network request ^(NSError *error) &#123;</span></span><br><span class="line">    <span class="comment">//     if (error) &#123;</span></span><br><span class="line">    <span class="comment">//         rollback</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>记得面试题的那篇文章里还调侃说 “面试的时候聊聊设计、架构挺好的，但别整出个往 UIButton 的子类里搞网络请求的奇葩结构就行”，结果就被自己打了个脸。不过从设计上，Self-Manager 模式并没有破坏原有的 MVC 结构，上面两个例子中的 View 依然可以不耦合具体业务逻辑的单拿出来用。使用 Category 的方式把应该写在 ViewController 中的代码移动到 View 的文件中，让功能更加的内聚。</p>
<p>程序的复杂度并不会因哪种酷炫的设计模式所减少，能做到的只是对复杂度的切分和控制，即：</p>
<ol>
<li>让一大坨恶心的代码变成几小坨不那么恶心的代码。</li>
<li>让恶心的代码只在一个地方恶心。</li>
</ol>
<p>Self-Manager 模式我们实践的时候写起来很开心，抛砖引玉一下，希望也能解决你的苦恼。</p>
<p><img src="http://ww1.sinaimg.cn/mw600/66b3de17gw1ez4zbk10vaj20go0ciwhd.jpg" width="320"></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/22/objc-class-extension-tips/" class="prev">上一篇</a><a href="/2015/09/13/class-ivar-layout/" class="next">下一篇</a></div><div data-thread-key="2015/12/19/self-manager-pattern-in-ios/" data-title="iOS 开发中的 Self-Manager 模式" data-url="http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"sunnyxx"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5 </p><p>对博主感兴趣？微信订阅号中关注 sunnyxx 或关注微博<a href="http://weibo.com/1364395395/">@我就叫Sunny怎么了</a></p><p>© 2015 - 2016  <a href="http://blog.sunnyxx.com">sunnyxx</a> | Powered by Hexo</p></div></footer></body></html>
